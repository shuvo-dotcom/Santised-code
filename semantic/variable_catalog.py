"""
Dynamic variable catalog for NFG analytics. Uses LLM provider for all mappings.
No hardcoded mappings - all determined by LLM at runtime.
Scope: electricity & gas systems, generation, fuels, storage, networks.
"""
import logging
from typing import Dict, Any, List, Optional, Tuple, Callable

logger = logging.getLogger(__name__)

# Start with empty dictionaries - everything will be generated by LLM at runtime
DEFAULT_FALLBACK_VALUES = {}
VARIABLE_MAP = {}

# No YAML files - all mappings will be dynamically determined by LLM
VARIABLE_MAP = {}

class VariableCatalog:
    def __init__(self, variable_map: Dict[str, Any] = None, fallback_values: Dict[str, Dict[str, float]] = None):
        """
        Initialize variable catalog with variable map.
        
        Args:
            variable_map: Optional map of canonical variables to properties/units
            fallback_values: Optional map of fallback values for variables
        """
        self.variable_map = variable_map or VARIABLE_MAP
        # Add mapping for UNIT_CAPACITY_MW to handle both file formats
        self.variable_map["UNIT_CAPACITY_MW"] = [
            ("capacity_mw", "MW", lambda v: v),  # For generators.csv format
            ("value", "MW", lambda v: v)  # For systemgenerators.csv format with property_name='Installed Capacity'
        ]
        self.fallback_values = fallback_values or DEFAULT_FALLBACK_VALUES
        self.llm_provider = None  # Will be set by pipeline
        
    def set_llm_provider(self, provider):
        """Set LLM provider for dynamic variable mapping"""
        self.llm_provider = provider
    
    def get_mappings(self, canonical_var: str, available_properties: List[str] = None) -> List[Tuple[str, str, Callable]]:
        """
        Get mappings for a canonical variable.
        Always determined dynamically by LLM at runtime.
        
        Args:
            canonical_var: Canonical variable name
            available_properties: Optional list of available properties in the CSVs
            
        Returns:
            List of tuples (property_name, unit_name, transform_fn)
        """
        # Check if we already have this mapping in memory cache
        if canonical_var in self.variable_map and self.variable_map[canonical_var]:
            try:
                mappings = self.variable_map[canonical_var]
                if isinstance(mappings, list):
                    if isinstance(mappings[0], tuple):
                        return mappings  # Already in correct format
                    elif isinstance(mappings[0], dict):
                        # Convert from dict format to tuple format with identity transform
                        return [(m.get('property_name'), m.get('unit_name', ''), lambda v: v) for m in mappings]
            except (IndexError, KeyError, AttributeError):
                logger.warning(f"Invalid mapping format in memory for {canonical_var}, will regenerate")
        
        # Always try to determine dynamically using LLM
        if self.llm_provider is not None and available_properties:
            try:
                llm_mappings = self.llm_provider.get_variable_mapping(canonical_var, available_properties)
                if llm_mappings:
                    # Convert to tuple format with identity transform
                    mappings = [(m.get('property_name'), m.get('unit_name', ''), lambda v: v) for m in llm_mappings]
                    
                    # Cache in memory for future use
                    self.variable_map[canonical_var] = mappings
                    
                    return mappings
            except Exception as e:
                logger.error(f"Error determining mapping for {canonical_var}: {str(e)}")
                
        # Return empty list if not found
        return []
    
    def get_fallback_value(self, canonical_var: str, filters: Dict[str, Any] = None) -> float:
        """
        Get a reasonable fallback value for a variable based on filters.
        Always determined dynamically by LLM at runtime.
        
        Args:
            canonical_var: Canonical variable name
            filters: Optional filters like tech, country, year
            
        Returns:
            A reasonable fallback value for the variable
        """
        # Check in-memory cache for performance
        key = f"{canonical_var}_{filters.get('tech', '')}" if filters else canonical_var
        if key in self.fallback_values:
            return self.fallback_values[key]
        
        # Always use LLM for dynamic determination
        if self.llm_provider is not None:
            try:
                # First try specific fallback value method
                if hasattr(self.llm_provider, 'get_fallback_value'):
                    fallback = self.llm_provider.get_fallback_value(canonical_var, filters)
                    if fallback is not None:
                        # Cache the result for future use
                        self.fallback_values[key] = fallback
                        return fallback
                        
                # Then try general guessing method
                if hasattr(self.llm_provider, 'guess_reasonable_value'):
                    guessed_value = self.llm_provider.guess_reasonable_value(canonical_var, filters)
                    if guessed_value is not None:
                        # Cache the result for future use
                        self.fallback_values[key] = guessed_value
                        return guessed_value
            except Exception as e:
                logger.error(f"Error getting fallback for {canonical_var} using LLM: {str(e)}")
        
        # Absolute last resort - use a simple heuristic based on variable name
        logger.warning(f"Failed to get value from LLM for {canonical_var}, using simple heuristic")
        
        if "CAPACITY" in canonical_var and "MW" in canonical_var:
            fallback = 100.0
        elif "GENERATION" in canonical_var:
            fallback = 500.0
        elif "COST" in canonical_var:
            fallback = 1000.0
        elif "RATE" in canonical_var:
            fallback = 0.08
        else:
            fallback = 100.0
            
        # Cache this last resort value
        self.fallback_values[key] = fallback
        return fallback
